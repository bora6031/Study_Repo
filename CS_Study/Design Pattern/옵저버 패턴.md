## **옵저버 패턴**

:상태를 가지고 있는 주체 객체 & 상태의 변경을 알아야 하는 관찰 객체

- 1 대 1 or 1 대 N 관계

> 서로의 정보를 주고받는 과정에서 정보의 단위가 클수록, 객체들의 규모가 클수록 복잡성이 증가하게 된다. 이때 가이드라인을 제시해줄 수 있는 것이 '옵저버 패턴'
> 
- 어떤 객체의 상태가 변할 때 그와 연관된 객체 들에게 알림을 보내는 디자인패턴
- 이벤트 들을 감시하여 이벤트가 발생할 때마다 어떠한 동작을 즉각 수행하게 해주는 프로그래밍 패턴

### 구현 원리

> 인터페이스를 이용한다. A와 B클래스가 있다고 가정, 두개의 클래스 사이에 인터페이스를 하나 끼워놓는다.
> 
1. A는 인페이스를 상속하여 이벤트가 발생할 때마다 실행되게 할 메소드를 구현
2. B를 생성할 때 인터페이스 구현체를 전달
3. 이벤트가 발생할 때마다 생성자로 전달받은 A가 구현한 인터페이스 메소드를 호출

<aside>
💡 이때 이 인터페이스를 옵저버 라고 부른다(코틀린→ 리스너)/ B가 구현된 인터페이스를 호출함으로써 이벤트를 전달하는 행위를 콜백이라고 한다.

</aside>

### 예시

- 주제 인터페이스와 구현체

```java
interface Subject {
	registerObserver() // 옵저버 등록
	removeObserver() // 옵저버 삭제
	notifyObserver() // 옵저버에게 업데이트 알림
}

class SubjectImpl implements Subject {
	registerObserver() { ... }
	removeObserver() { ... }
	notifyObserver() { ... }

	getState() // 주제 객체는 상태를 설정하고 알기위한 겟터,셋터가 있을 수 있다.
	setState()
}
```

- 옵저버 인터페이스와 구현체

```java
interface Observer{ // 옵저버가 될 객체에서는 반드시 Observer 인터페이스를 구현해야함.
	update() // 주제의 상태가 바뀌었을때 호출됨
}

class ObserverImpl implements Observer {
	update() { 
		// 주제가 업데이트 될 때 해야하는 일
	}
}
```
