# 트랜잭션 격리 수준

> 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에셔 변경하거나 조회하는 데이터를 볼 수 있도록 허용할 지 말지를 결정하는 것
> 

### 4가지의 격리 수준

- **READ UNCOMMITTED(커밋되지 않은 읽기)**
- **READ COMMITTED(커밋된 읽기)**
- **REPEATABLE READ(반복 가능한 읽기)**
- **SERIALIZABLE(직렬화 가능)**

**READ UNCOMMITTED의 격리 수준이 가장 낮고 SERIALIZABLE의 격리 수준이 가장 높음.**
.

### 트랜잭션 격리 수준이 필요한 이유

- 트랜잭션 수준읽기 일관성을 지키기 위해
    - 트랜잭션이 시작된 시점으로부터 일관성 있게 데이터를 읽어 들이는 것을 말한다.하나의 트랜잭션이 진행되는 동안 다른 트랜잭션에의해 변경사항이 발생하더라도 이를 무시하고 계속 일관성 있는 데이터를 보여준다. (물론 트랜잭션 자신이 발생한 변경사항은 읽을 수 있다)
- 동시성 제어 문제 해결을 위함

### **READ UNCOMMITTED (트렌젝션 레벨 0)**

트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.

- 특징
    - dirty read, non-repeatable read, phantom read 현상이 발생
- 문제점
    - 데이터 정합성에 문제가 많다
    - rdbms 표준에서는 격리 수준으로 인정하지 않는다.

### **READ COMMITTED (트렌젝션 레벨 1)**

RDB에서 대부분 기본적으로 사용되고 있는 격리 수준으로 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드 에서 값을 가져온다.

- 특징
    - dirty read 가 발생하지 않지만 non-repeatable read, phantom read 현상은 발생
    - 온라인 서비스에서 가장 많이 선택되는 격리 수준이다.
        - DB2, SQL Server, Sybase의 경우 `읽기, 공유 Lock`을 이용하여 구현한다
        - Oracle은 Lock을 사용하지 않고 쿼리시작 시점의 `Undo 데이터`를 제공한다
- 문제점
    - non-repeatable read 부정합 문제가 발생할 수 있다.
    - read commited 격리 수준에서 실행되는 sql 문장의 결과가 무엇인지 정확히 예측하고 있어야 한다.

### **REPEATABLE READ (트렌젝션 레벨 2)**

트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리수준이다.

- MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 **트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.**
- 변경되기 전 레코드는 `Undo 공간`에 백업해두고 `실제 레코드 값`을 변경한다
- 특징
    - `Dirty Read`와 같은 현상은 발생하지 않지만 `Phantom Read`현상은 여전히 발생한다.
- 문제점
    - 하나의 트랜잭션 실행시간이 길어질수록 **Undo에 백업된 레코드가 많아져서 멀티 버전을 관리해야하는 단점**이 있다.
    - update 부정합과 phantom read가 발생할 수 있다.

### **SERIALIZABLE (트렌젝션 레벨 3)**

선행 트랜잭션이 특정 테이블을 읽는 경우(`SELECT`) `공유 잠금(shared lock)`을 걸어, 다른 트랜잭션에서 해당 테이블의 데이터를 `UPDATE`, `DELETE`, `INSERT` 작업을 못하도록 막는다.

- 특징
    - 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준으로 phantom read가 발생하지 않는다.
- 문제점
    - 동시처리 능력이 다른 격리 수준보다 떨어지고 성능 저하가 발생하여 데이터베이스에서 거의 사용되지 않는다.
