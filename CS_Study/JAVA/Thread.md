# Thread

### 멀티 스레딩

: 하나의 프로세스 안에 여러개의 스레드가 동시에 작업을 수행하는 것 

- 스래드= 하나의 작업 단위

### 스레드 구현

1. Runnable인터페이스 구현
    - 해당 클래스를 인스턴스화해서 Thread 생성자에 argument로 넘겨줘야 한다.
    - 그리고 run()을 호출하면 Runnable 인터페이스에서 구현한 run()이 호출되므로 따로 오버라이딩하지 않아도 되는 장점이 있다.
2. Thread 클래스 상속
    - 상속받은 클래스 자체를 스레드로 사용할 수 있다.
    - 스레드 클래스의 메소드(getName())를 바로 사용할 수 있지만, Runnable 구현의 경우 Thread 클래스의 static 메소드인 currentThread()를 호출하여 현재 스레드에 대한 참조를 얻어와야만 호출이 가능하다.

```java
public class MyThread implements Runnable {
    @Override
    public void run() {
        // 수행 코드
    }
}
```

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        // 수행 코드
    }
}
```

- 위의 두 방법은 인스턴스 생성 방법에 차이가 있다.

### 스레드 실행

: 스레드의 실행은 run() 호출이 아닌 start() 호출로 해야한다. 

- java에는 call stack이 있다.
- 스레드를 이용한다는 건, JVM이 다수의 콜 스택을 번갈아가며 일처리를 하고 사용자는 동시에 작업하는 것처럼 보여준다.
- 여기서 run()메소드를 이용한다는 것은 main()의 콜스택 하나만을 이용하는 것으로 스레드 활용이 아니다.
- start()메소드를 호출하면 JVM이 알아서 스레드를 위한 콜스택을 만들어주고 context switching을 통해 스레드 답게 동작하도록 해준다.

### **스레드의 실행제어**

> 스레드의 상태는 5가지가 있다
> 
- NEW : 스레드가 생성되고 아직 start()가 호출되지 않은 상태
- RUNNABLE : 실행 중 또는 실행 가능 상태
- BLOCKED : 동기화 블럭에 의해 일시정지된 상태(lock이 풀릴 때까지 기다림)
- WAITING, TIME_WAITING : 실행가능하지 않은 일시정지 상태
- TERMINATED : 스레드 작업이 종료된 상태

### **동기화**

멀티스레드로 구현을 하다보면, 동기화는 필수적이다.

동기화가 필요한 이유는, **여러 스레드가 같은 프로세스 내의 자원을 공유하면서 작업할 때 서로의 작업이 다른 작업에 영향을 주기 때문**이다.

스레드의 동기화를 위해선, 임계 영역(critical section)과 잠금(lock)을 활용한다.

임계영역을 지정하고, 임계영역을 가지고 있는 lock을 단 하나의 스레드에게만 빌려주는 개념으로 이루어져있다.

따라서 임계구역 안에서 수행할 코드가 완료되면, lock을 반납해줘야 한다.

### **스레드 동기화 방법**

- 임계 영역(critical section) : 공유 자원에 단 하나의 스레드만 접근하도록(하나의 프로세스에 속한 스레드만 가능)
- 뮤텍스(mutex) : 공유 자원에 단 하나의 스레드만 접근하도록(서로 다른 프로세스에 속한 스레드도 가능)
- 이벤트(event) : 특정한 사건 발생을 다른 스레드에게 알림
- 세마포어(semaphore) : 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때 접근 제한
- 대기 가능 타이머(waitable timer) : 특정 시간이 되면 대기 중이던 스레드 깨움
